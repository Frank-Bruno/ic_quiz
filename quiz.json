{
    "title": "Quiz de Conceitos de ML (Capítulo 2 - Géron)",
    "questions": [
        {
            "text": "Qual é a principal distinção funcional entre um objeto *NumPy array* e um *pandas DataFrame* no contexto do pré-processamento de dados em Python?",
            "options": [
                "O DataFrame pode conter dados heterogêneos e usa eixos rotulados (nomes de colunas/índice), enquanto o NumPy é homogêneo e indexado numericamente.",
                "NumPy é uma biblioteca de alto nível para análise de dados, enquanto Pandas é de baixo nível para computação numérica.",
                "O DataFrame é exclusivamente para atributos numéricos e o NumPy para atributos categóricos.",
                "NumPy é mais rápido que Pandas em todas as etapas, incluindo o carregamento de arquivos CSV."
            ],
            "correct_option": 0
        },
        {
            "text": "O que é um *ML pipeline* (pipeline de Machine Learning)?",
            "options": [
                "Um método de avaliação de modelo utilizando Validação Cruzada.",
                "Uma sequência de componentes de processamento de dados que consomem a saída do anterior, permitindo manipulação e transformação de dados.",
                "O modelo final treinado (Estimator) pronto para fazer predições.",
                "Um arquivo único para armazenar grandes conjuntos de dados (como CSV ou TGZ)."
            ],
            "correct_option": 1
        },
        {
            "text": "Qual é a principal diferença entre a aprendizagem Supervisionada (*Supervised Learning*) e a Não Supervisionada (*Unsupervised Learning*)?",
            "options": [
                "Supervised Learning usa algoritmos que exigem o treinamento em instâncias não rotuladas (sem $y$).",
                "Unsupervised Learning prevê um valor contínuo, enquanto Supervised Learning faz classificação.",
                "Supervised Learning treina o sistema com exemplos rotulados (pares de entrada $x$ e saída desejada $y$).",
                "Unsupervised Learning é usado exclusivamente para problemas de Regressão."
            ],
            "correct_option": 2
        },
        {
            "text": "No contexto de Regressão, qual tipo de problema é definido como *Multiple Regression* (Regressão Múltipla)?",
            "options": [
                "Prever um único valor de saída, mas usando múltiplos atributos (*features*) de entrada.",
                "Prever múltiplos valores de saída simultaneamente.",
                "Prever um único valor de saída, usando apenas um único atributo (Univariate).",
                "Um problema de Classificação com mais de dez classes."
            ],
            "correct_option": 0
        },
        {
            "text": "Quando um *dataset* é muito grande e não cabe na memória, qual abordagem de treinamento é a mais recomendada, além da divisão do trabalho em vários servidores (e.g., MapReduce)?",
            "options": [
                "Exclusivamente *Batch Learning*.",
                "Apagar atributos que possuem muitos valores nulos.",
                "Amostragem Estratificada para reduzir o tamanho.",
                "Utilizar *Online Learning* (ou *Incremental Learning*), processando os dados em pequenas partes."
            ],
            "correct_option": 3
        },
        {
            "text": "Qual é a principal característica da aprendizagem em lote (*Batch Learning*)?",
            "options": [
                "O sistema é treinado de forma incremental, adaptando-se a dados novos rapidamente.",
                "O sistema é treinado usando todos os dados disponíveis de uma vez, geralmente *offline*.",
                "O sistema utiliza apenas uma pequena amostra do conjunto de dados total.",
                "O sistema precisa estar conectado à internet em tempo real."
            ],
            "correct_option": 1
        },
        {
            "text": "Qual a relação entre o *Root Mean Square Error* (RMSE) e o conceito de Norma Euclidiana?",
            "options": [
                "RMSE é a média aritmética do vetor de erros.",
                "RMSE é a norma $\\ell_1$ (distância de Manhattan).",
                "O RMSE corresponde à norma Euclidiana do vetor de erros.",
                "O RMSE é usado apenas em problemas de Classificação."
            ],
            "correct_option": 2
        },
        {
            "text": "Qual é a principal vantagem de usar um *Jupyter Notebook* ou Google Colab em comparação com um script Python simples para o desenvolvimento e visualização de projetos de ML?",
            "options": [
                "Permite o uso de bibliotecas de terceiros como o Scikit-Learn.",
                "É mais seguro para armazenar credenciais de acesso a dados.",
                "Jupyter permite a interatividade, execução célula por célula e a mistura de código com texto e figuras (como Markdown).",
                "Scripts Python não podem ser executados no navegador."
            ],
            "correct_option": 2
        },
        {
            "text": "Qual é o significado da extensão de arquivo `.tgz` mencionada no processo de obtenção de dados e o que faz o comando `tar xzf`?",
            "options": [
                "Um arquivo de texto simples (TXT).",
                "Um arquivo de vídeo compactado (MPEG).",
                "Um arquivo de log (LOG).",
                "Um arquivo compactado (*tar gzipped archive*), e `tar xzf` o extrai (eXtracts)."
            ],
            "correct_option": 3
        },
        {
            "text": "O que significa o acrônimo CSV e qual a sua principal aplicação?",
            "options": [
                "Computed Statistics Vector.",
                "Consolidated System Version.",
                "Comma-Separated Values (Valores Separados por Vírgula), usado para dados tabulares.",
                "Categorical Scaling Vector."
            ],
            "correct_option": 2
        },
        {
            "text": "Em um contexto de ML supervisionado (dado $(x, y)$), o que representam a *instância* (ou exemplo) e o *label* (rótulo)?",
            "options": [
                "A instância é a predição $h(x)$, e o label é a função de custo.",
                "A instância é o vetor de *features* x, e o label é o valor de saída desejado y.",
                "A instância é o parâmetro do modelo, e o label é o erro.",
                "A instância é a dispersão, e o label é a média."
            ],
            "correct_option": 1
        },
        {
            "text": "Qual a relação entre *std* (*standard deviation* - desvio padrão) e *variance* (variância) em estatística descritiva de atributos numéricos?",
            "options": [
                "O desvio padrão é o quadrado da variância.",
                "A variância é a raiz cúbica do desvio padrão.",
                "A variância mede a dispersão, enquanto o desvio padrão é a raiz quadrada da variância.",
                "Ambos medem a centralidade dos dados, como a média."
            ],
            "correct_option": 2
        },
        {
            "text": "O que representam os valores do 25º percentil (*first quartile*) e do 75º percentil (*third quartile*) ao descrever um atributo numérico?",
            "options": [
                "Apenas os valores mínimos e máximos do atributo.",
                "Os pontos que dividem o conjunto de dados em subgrupos homogêneos.",
                "Os valores abaixo dos quais 25% e 75% das observações se encontram, respectivamente.",
                "A média e a mediana do atributo."
            ],
            "correct_option": 2
        },
        {
            "text": "Por que o uso da função `plt.show()` pode ser opcional em um *Jupyter Notebook*, mas é frequentemente necessário em um script Python regular?",
            "options": [
                "Jupyter ignora o código Matplotlib e usa outro motor de renderização.",
                "Jupyter (ou Colab) automaticamente exibe os gráficos quando a célula é executada.",
                "Scripts Python não podem renderizar gráficos de dispersão.",
                "A função `show()` é reservada apenas para modelos treinados."
            ],
            "correct_option": 1
        },
        {
            "text": "No contexto da distribuição de atributos, o que caracteriza uma distribuição *tail-heavy* (cauda pesada) e qual a implicação para o pré-processamento?",
            "options": [
                "A distribuição é perfeitamente simétrica (bell-shaped).",
                "A distribuição é uniforme entre zero e um.",
                "Possui caudas longas, afetada por *outliers* (valores atípicos), e pode exigir transformação (e.g., log) para se tornar mais simétrica.",
                "É uma distribuição esparsa (Sparse)."
            ],
            "correct_option": 2
        },
        {
            "text": "Explique detalhadamente o que é o *data snooping bias* (viés de bisbilhotice de dados).",
            "options": [
                "Ocorre quando o modelo é treinado de forma incremental (online).",
                "Ocorre quando a divisão dos dados não é aleatória.",
                "Ocorre quando a estimativa de erro de generalização se torna otimista por usar o conjunto de teste inadvertidamente.",
                "É a tendência do modelo em prever valores nulos."
            ],
            "correct_option": 2
        },
        {
            "text": "Qual é a função do *random number generator's seed* ao dividir um conjunto de dados em treino e teste (e.g., em Scikit-Learn)?",
            "options": [
                "Determinar a taxa de aprendizado do modelo.",
                "Garantir que os dados sejam sempre padronizados (Standardization).",
                "Assegurar que a divisão aleatória dos dados seja a mesma em execuções subsequentes (reprodutibilidade).",
                "Inicializar os pesos de uma Rede Neural."
            ],
            "correct_option": 2
        },
        {
            "text": "O que é *stratified sampling* (amostragem estratificada) e qual seu objetivo principal na divisão de conjuntos de dados?",
            "options": [
                "Dividir aleatoriamente a população sem considerar a distribuição de atributos.",
                "Dividir a população em subgrupos homogêneos (*strata*) para garantir que o conjunto de teste seja representativo das proporções populacionais.",
                "Amostrar apenas as instâncias que são *outliers*.",
                "Garantir que a correlação entre os atributos seja zero."
            ],
            "correct_option": 1
        },
        {
            "text": "Qual é a abordagem recomendada (imputação) para lidar com valores ausentes (*missing values*) em um atributo numérico usando Scikit-Learn (e.g., com `SimpleImputer`)?",
            "options": [
                "Apagar o atributo (coluna) inteiro.",
                "Substituir os valores nulos por um valor aleatório.",
                "Apagar todas as instâncias (linhas) que contêm o valor nulo.",
                "Calcular uma estatística (e.g., mediana) no conjunto de **treinamento** e usá-la para preencher os valores ausentes."
            ],
            "correct_option": 3
        },
        {
            "text": "Por que, no pré-processamento de atributos categóricos não ordenados, a codificação *One-Hot Encoding* é geralmente preferível à codificação numérica natural (Ordinal Encoding)?",
            "options": [
                "A Codificação Numérica Natural implica uma relação de ordem ou distância artificial entre categorias não ordenadas.",
                "One-Hot Encoding usa menos memória.",
                "One-Hot Encoding é mais rápido para ser calculado.",
                "Codificação Numérica Natural sempre resulta em *sparsity* (esparsidade)."
            ],
            "correct_option": 0
        },
        {
            "text": "O Coeficiente de Pearson (ou coeficiente de correlação padrão) mede qual tipo de relação entre dois atributos?",
            "options": [
                "A relação não-linear (curva) entre os atributos.",
                "A dispersão e a média dos atributos.",
                "A correlação linear entre os atributos.",
                "O grau de esparsidade de um vetor."
            ],
            "correct_option": 2
        },
        {
            "text": "Por que o método *Min-Max scaling* é mais suscetível a ser afetado por *outliers* (valores atípicos) do que a *Standardization* (padronização)?",
            "options": [
                "A Standardization não utiliza a média.",
                "O Min-Max scaling usa valores mínimos e máximos que são sensíveis e distorcidos por *outliers*.",
                "O Min-Max scaling exige que a distribuição seja Gaussiana.",
                "A Standardization força os dados para um intervalo fixo."
            ],
            "correct_option": 1
        },
        {
            "text": "Ao aplicar *feature scaling* (Min-Max ou Standardization), por que os parâmetros do *scaler* (como média, desvio padrão, min e max) devem ser calculados (treinados) **somente** no conjunto de treinamento?",
            "options": [
                "O conjunto de teste é pequeno demais para ter estatísticas válidas.",
                "Apenas dados categóricos precisam de treinamento de *scaler*.",
                "Para evitar *data leakage* (vazamento de dados) do conjunto de teste para o treinamento.",
                "O `fit()` deve ser chamado no conjunto de teste e o `transform()` no conjunto de treinamento."
            ],
            "correct_option": 2
        },
        {
            "text": "Qual é a principal vantagem de usar *Randomized Search* (e a classe `RandomizedSearchCV`) em vez de *Grid Search* (`GridSearchCV`) para ajustar hiperparâmetros, especialmente em espaços de busca grandes?",
            "options": [
                "Grid Search é mais eficiente para explorar espaços de hiperparâmetros contínuos.",
                "Randomized Search avalia combinações aleatórias, permitindo explorar espaços vastos de forma mais eficiente do que testar todas as combinações em uma grade (Grid).",
                "Randomized Search garante o ótimo global em menos tempo.",
                "Grid Search permite a definição de distribuições de probabilidade para a amostragem."
            ],
            "correct_option": 1
        },
        {
            "text": "O que são *Ensemble Methods* e qual sua função principal no aprimoramento de modelos de ML?",
            "options": [
                "Métodos para realizar *feature scaling* em atributos numéricos.",
                "Métodos que combinam vários modelos (*estimators*) (e.g., *Random Forests*) para obter um desempenho geralmente melhor do que os modelos individuais.",
                "Uma técnica para remover valores nulos (Imputation).",
                "Algoritmos de *Unsupervised Learning* (não supervisionados)."
            ],
            "correct_option": 1
        },
        {
            "text": "Segundo os princípios de design do Scikit-Learn, o que define um *Transformer* (Transformador)?",
            "options": [
                "Qualquer objeto que implementa apenas o método `predict()`.",
                "Um objeto que pode estimar parâmetros (`fit()`) e transformar um dataset (`transform()`).",
                "Um objeto que só tem o método `score()`.",
                "Apenas a etapa final de um *ML pipeline* que faz predições."
            ],
            "correct_option": 1
        },
        {
            "text": "Para lidar com atributos numéricos que possuem distribuições *tail-heavy* (caudas pesadas) ou assimétricas, qual tipo de transformação é frequentemente aplicado para aproximá-los de uma distribuição simétrica (*bell-shaped*)?",
            "options": [
                "A codificação One-Hot Encoding.",
                "Transformações não-lineares, como aplicar o logaritmo ou a raiz quadrada.",
                "O cálculo da correlação de Pearson.",
                "A remoção de todos os valores acima do 75º percentil."
            ],
            "correct_option": 1
        },
        {
            "text": "Qual é a métrica de desempenho de Regressão que é mais sensível a grandes erros (*outliers*), sendo geralmente preferida por penalizar mais as predições distantes?",
            "options": [
                "O Mean Absolute Error (MAE).",
                "O Coeficiente de Pearson.",
                "O Root Mean Square Error (RMSE).",
                "A Variância."
            ],
            "correct_option": 2
        },
        {
            "text": "Quando um sistema de ML é implantado (*launch, monitor, and maintain*), por que é crucial monitorar o desempenho do sistema em produção?",
            "options": [
                "Porque o *data snooping bias* reaparece após o lançamento.",
                "Para garantir que a divisão em treino/teste foi correta.",
                "Para detectar 'model rot' (decaimento do modelo), no qual o desempenho se degrada devido à evolução dos dados ao longo do tempo.",
                "Para aplicar *cross-validation* continuamente."
            ],
            "correct_option": 2
        },
        {
            "text": "O que a Validação Cruzada (*Cross-Validation*) permite ao avaliar um modelo, que o uso de um único conjunto de validação não oferece?",
            "options": [
                "Evitar a necessidade de *feature scaling*.",
                "Obter uma estimativa de erro de generalização mais estável e uma estimativa de quão precisa é essa estimativa (e.g., através do std dos *folds*).",
                "Garantir que o modelo não faça *overfitting* de forma alguma.",
                "Apenas a média do RMSE, sem o desvio padrão dos resultados."
            ],
            "correct_option": 1
        }
    ]
}